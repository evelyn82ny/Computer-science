# 4-way handshake

TCP 통신에서 데이터 송수신 전에 서로 데이터를 주고 받을 수 있는 상태인지 체크하는 것을 **3-way handshake**라고 한다.<br>
**4-way handshake**는 서로간의 연결을 종료하기 위해 발생되는 개념이고, 결론만 말하면 좋은 방식은 아니다.<br>

## TCP 소켓의 입출력 버퍼

TCP 소켓마다 입출력 버퍼가 존재하는데 이는 소켓 생성시 자동으로 생성된다.<br>

![png](/_img/tcp_buffer.png) <br>

입력 버퍼에 있는 데이터를 read()로 읽고, write()하면 출력 버퍼에 쌓인다.<br>
출력 버퍼에 쌓인 데이터는 상대방의 입력 버퍼에 쌓이는 방식이다.<br>

하지만 입출력 버퍼에 데이터가 있는 상태로 close()를 호출하면 어떻게 될까?<br>
- 입력 버퍼에 데이터가 있는 상태에서 close()로 소켓을 닫으면 입력버퍼에 있는 데이터는 소멸된다.
- 출력 버퍼에 데이터가 있는 상태에서 close()로 소켓을 닫아도 일단 데이터를 모두 전송한 다음 버퍼를 닫는다.

즉, close()를 호출해도 출력 버퍼에 있는 데이터(전송해야하는 데이터)가 상대방에게 전달하는 것을 보장한다.<br>
하지만 상대방에게 전달하는 것을 보장하는 것이지 상대방이 받았다는 것을 보장하는 게 아니다.<br>

만약 상대가 나보다 먼저 소켓을 닫은 경우 이미 입력 버퍼가 닫혀있기 때문에 내가 데이터를 보냈다해도 받을 방법이 없다. 정말 전송의 의무만 다하는 것이다.<br>
이는 효율적인 방법이 아니다.<br><br>

## 4-way handshake

![png](/_img/4-way-handshake.png)

> 출처 : https://sjlim5092.tistory.com/37 <br>

- host A가 close()를 호출해 소켓을 닫겠다라는 의미가 담긴 패킷을 host B에게 보냈다.
- 소켓을 닫겠다라는 패킷을 받은 host B는 **'연결을 종료하겠다는 것을 일단 알고있겠다...'** 라는 의미로 해당 패킷에 대한 응답을 보낸다.
- host B는 출력 버퍼에 남은 데이터를 일단 host A에게 보내고 close()를 호출해 **'나도 연결을 종료하겠다.'** 라는 패킷을 한번더 보낸다.
- host A는 이에 대한 응답을 보낸다.

이렇게 4번의 패킷 전송으로 인해 연결이 종료되므로 이를 ```4-way handshake```라고 한다.

// 내용 추가 예정